# остаток от деления большего на меньшее или равное
# код не будет работать из за ошибки в функции Div_NN_N
# можно писать доп условия с увеличением остатка при ситуации 2,399 до 2,4. . . А оно надо ?
def MOD_NN_N(num1: NNumber, num2: NNumber):
    
    x = 0 # < - для увеличение разрядности первого числа, можно увеличить разрядность путём создания вместа x массива 0
    # берём целое от деления
    k = DIV_NN_N(num1,num2)
    k.reverse()
    k.append(x) # увеличиваем разрядность
    num1 = num1.get_num()
    num1.reverse()
    num1.append(x) # увеличиваем разрядность первого чила 
    num1 = NNumber(num1)
    # находим частное от большего первого и оригинального второго - получаем большее по разрядности частное(включающее первую цифру остатка)
    l = DIV_NN_N(num1,num2)
    # к примеру, при 10 и 4: l = 2, k = 25, увеличиваем l до 20, находим k = 25 (100/4), далее k - l = 5/ / / наш остаток
    res = SUB_NDN_N(k,1,l)
    return res
